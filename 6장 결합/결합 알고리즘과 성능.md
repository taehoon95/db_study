# 결합 알고리즘과 성능
- Nested Loops
- Hash
- Sort Merge

## 1. Nested Loops
### 1-1. 작동
1. 결합 대상 테이블(Table_A)에서 레코드를 하나씩 반복해가며 스캔한다. 이 테이블을 구동 테이블(driving table) 또는 외부 테이블(outer table)이라고 부른다. 다른 테이블(Table_B)은 내부 테이블(inner table)이라고 부른다.
2. 구동 테이블의 레코드 하나마다 내부 테이블의 레코드를 하나씩 스캔해서 결합 조건에 맞으면 리턴한다.
3. 이러한 작동을 구동 테이블의 모든 레코드에 반복한다.

### 1-2. 특징
1. Table_A, Table_B의 결합 대상 레코드를 R(A), R(B)라고 하면 접근되는 레코드 수는 R(A) X R(B)가 된다. Nested Loops의 실행 시간은 이러한 레코드 수에 비례한다.
2. 한 번의 단계에서 처리하는 레코드 수가 적으므로 Hash 또는 Sort Merge에 비해 메모리 소비가 적다.
3. 모든 DBMS에서 지원한다.
- 구동 테이블이 작을수록 Nested Loops의 성능이 좋아진다.

### 1-3. 구동 테이블의 중요성
- __내부 테이블의 결합 키 필드에 인덱스가 존재__ 하는 이상적인 경우는 결합 키가 내부 테이블에 대해 유일한 경우뿐이다. 이때 등치 결합이라면 내부 테이블의 접근 대상 레코드를 한 개로 한정할 수 있으므로, 이중 반복의 내측에 있는 반복을 완전하게 생략할 수 있다.

### 1-4. Nested Loops의 단점
- 결합 키로 내부 테이블에 접근할 때 히트되는 레코드가 너무 많으면 기대만큼의 응답 시간이 나오지 않기도 한다. 결국 절대적인 양이 너무 많으면 반복이 많이 일어난다.
- 대처방법
  1. 구동 테이블로 큰 테이블을 선택하는 역설적인 방법: 내부 테이블에 대한 점포 테이블의 접근이 기본 키로 수행되므로, 항상 하나의 레코드로 접근하는 것이 보장된다. 따라서 점포에 따른 성능 비균등 문제를 해결해서, 극단적으로 성능이 저하되는 것을 막을 수 있다. 
  2. 해시

## 2. Hash
### 2-1. Hash의 작동
- 입력에 대해 어느 정도 유일성과 균일성을 가진 값을 출력하는 함수
- 해시 결합 수행 순서
  - 작은 테이블을 스캔, 결합 키에 해시 함수를 적용해서 해시값으로 변환한다. 이어서 다른 테이블(큰 테이블)을 스캔하고, 결합 키가 해시값에 존재하는지를 확인하는 방법으로 결합을 수행
  - 작은 테이블에서 해시 테이블을 만드는 이유: 해시 테이블은 DBMS의 워킹 메모리에 저장되므로 조금이라도 작은 것이 효율적이기 때문이다. Hash가 사용되는 경우는 어떤 한 쪽의 테이블이 극단적으로 작거나 크지 않다. 한 쪽 테이블이 극단적으로 작은 경우라면 Nested Loops가 좋다.
### 2-2. Hash의 특징
- 결합 테이블로부터 해시 테이블을 만들어서 활용하므로, Nested Loops에 비해 메모리를 크게 소모한다.
- 메모리가 부족하면 저장소를 사용하므로 지연이 발생한다.
- 출력되는 해시값은 입력값의 순서를 알지 못하므로, 등치 결합에만 사용할 수 있다.
### 2-3. Hash가 유용한 경우
- Nested Loops에서 적절한 구동 테이블(상대적으로 충분히 작은 테이블)이 존재하지 않는 경우
- 앞서 'Nested Loops의 단점'에서 본 것처럼 구동 테이블로 사용할만한 작은 테이블은 있지만, 내부 테이블에서 히트되는 레코드 수가 너무 많은 경우
- Nested Loops의 내부 테이블에 인덱스가 존재하지 않는(또는 여러 가지 사정에 의해 인덱스를 추가할 수 없는)경우
### 2-4 주의할 점
- 초기에 해시 테이블을 만들어야 하므로, Nested Loops에 비해 소비하는 메모리 양이 많다. OLTP처리(사용자 요구에 시스템이 곧바로 응답해야 하는 처리)를 할때 Hash를 사용하면 안 된다.

## 3. Sort Merge
### 3-1. Sort Merge의 작동
- Sort Merge는 결합 대상 테이블들을 각각 결합 키로 정렬하고, 일치하는 결합 키를 찾으면 결합한다.
### 3-2. Sort Merge의 특징
1. 대상 테이블을 모두 정렬해야 하므로 Nested Loops보다 많은 메모리를 소비한다. 
2. Hash는 한족 테이블에 대해서만 해시 테이블을 만드므로 Hash보다 많은 메모리를 사용하기도 한다.
3. Hash와 다르게 동치 결합뿐만 아니라 부등호(<, >, <=, >=)를 사용한 결합에도 사용할 수 있다. 하지만 부정 조건(<>) 결합에선느 사용할 수 없다.
4. 원리적으로 테이블이 결합 키로 정렬되어 있다면 정렬을 생략할 수 있다. 다만 이는 SQL에서 테이블에 있는 레코드의 물리적인 위치를 알고 있을 때입니다. 따라서 이러한 생략은 구현 의존적입니다.
5. 테이블을 정렬하므로 한쪽 테이블을 모두 스캔한 시점에 결합을 완료할 수 있다.
### 3-3. Sort Merge가 유효한 경우
- Sort Merge 결합 자체에 걸리는 시간은 결합 대상 레코드 수가 많더라도 나쁘지 않은 편이지만, 테이블 정렬에 많은 시간과 리소스를 요구할 가능성이 있다. 따라서 테이블 정렬을 생략할 수 있는 경우에는 고려해볼 만하지만, 그 이외의 경우는 Nested Loops와 Hash를 우선적으로 고려한다.

## 4. 의도하지 않는 크로스 결합
