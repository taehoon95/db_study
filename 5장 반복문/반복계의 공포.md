# 반복계의 공포
## 반복계의 단점
1. 반복계 처리 시간: <처리 횟수> * <한 회에 걸리는 시간> 이므로 <한 회에 걸리는 시간>이 일정 하다고 가정하면 처리 횟수(=처리 대상 레크드 수)에 비례한다.
2. SQL 실행의 오버 헤드
   - 전처리
     1. SQL 구문을 네트워크로 전송
     2. 데이터베이스 연결
     3. SQL 구문 파스
     4. SQL 구문의 실행 계획 생성 또는 평가
   - 후처리
     5. 결과 집합을 네트워크로 전송
   - 2-1. 오버 헤드 걸리는 곳
     - a, e의 전송속도자체는 고속인 만큼 오버헤드가 딱히 일어나지 않는다.
     - b는 데이터베이스에 SQL 구문을 실행하기 위한 작업, 데이터베이스에 연결해서 세션을 설정해야 하므로 발생하는 처리이다. 하지만 최근에는 Application에서 미리 연결을 일정 수 확보해서 이런 오버헤드를 감소시키는 Connection Pool 기술을 사용한다. 그래서 b도 거의 문제가 되지 않는다.
     - 오버헤드 중에서 가장 영향이 큰 것은 c 또는 d이다. 좀 더 성가신 것은 SQL 구문 파스(구문 분석)이다. 그리고 파스는 데이터베이스가 SQL을 받을 때마다 실행되므로 작은 SQL을 여러 번 반복하는 반복계에서 오버헤드가 높아질 수 밖에 없다.

3. 병렬 분산이 힘들다.
   - 반복계는 반복 1회마다 처리를 굉장히 단순화 한다. 따라서 리소스를 분산해서 병렬 처리하는 최적화가 안 된다. CPU의 멀티 코어로 분산 처리를 할 수 없는 것은 물론 저장소의 분산 효율이 낮다. 데이터베이스 서버 저장소는 대부분 RAID 디스크로 구성되어 I/O 부하를 분산할 수 있게 되어 있다. 하지만 반복계에서 실행하는 SQL 구문은 대부분 단순해서 1회의 SQL 구문이 접근하는 데이터양이 적다. 따라서 I/O를 병렬화 하기 힘들다는 단점이 있다. 

4. 데이터베이스의 진화로 인한 혜택을 받을 수 없다.
   - 데이터 베이스가 처리하는 데이터야은 최근 급격히 증가하고 있으며, 그에따라 어떻게 해야 SQL을 빠르게 할 수 있을지 계속 연구하고 있다. 따라서 DBMS의 버전이 오를수록 옵티마이저는 보다 효율적으로 실행 계획을 세우며, 데이터에 고속으로 접근할 수 있는 아키텍처를 구현한다. 하지만 단순한 SQL 구문과 같은 '가벼운'처리를 빠르게 만드는 것은 안중에도 없다.
   
## 반복계를 빠르게 만드는 방법
1. 반복계를 포장계로 다시 작성
2. 각각의 SQL을 빠르게 수정
3. 다중화 처리
   - 그나마 희망적인 선택지 이다. CPU 또는 디스크와 같은 리소스에 여유가 있고, 처리를 나눌 수 있는 키가 명확하게 정해져 있다면, 처리를 다중화해서 성능을 선형에 가깝게 스케일 할 수 있다. 하지만 반대로 데이터를 분할할 수 있는 명확한 키가 없거나, 순서가 중요한 처리, 병렬화 했을 때 물리 리소스가 부족하다면 이러한 방법은 사용 할 수 없다.

## 반복계의 장점
- 실행 계획의 단순함이 장점으로 나오기도 한다.
1. 실행 계획의 안정성 
   - 실행 계획이 단순하다는 것은 해당 실행 계획에 __변동 위험이 거의 없다__ 라는 것을 나타낸다. 특히 SQL 구문 내부에서 결합을 사용하지 않아도 된다는 것이 크게 작용한다. 실행 계획 변동에서 가장 골칫거리가 되는 것이 결합 알고리즘의 변경이기 때문이다. 옵티마이저가 안정적이지 않은 현재 시점에서 안정적인 성능을 확보 할 수 있게 된다.
2. 예상 처리 시간의 정밀도
   - 반복계 처리 시간은 : <처리 횟수> * <한 회에 걸리는 시간> 이므로 처리 시간을 예상 할 수 있다.
3. 트랜잭션 제어가 편리
   - 트랜잭션의 정밀도를 미세하게 제어할 수 있다. 예를 들어 갱신 처리를 반복계에서, 특정 반복 횟수마다 커밋한다고 하면 만약 중간에 오류가 발생했다고 해도, 중간에 커밋을 했으므로 해당 지점 근처에서 다시 처리를 실행하면 된다. 하지만 이러한 미세한 제어는 포장계의 SQL 구문 에서는 할 수 없는 것이다.